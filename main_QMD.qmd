---
title: 'DeVries Writing Project'
latex-engine: xelatex
format:
  pdf:
    fig-pos: 'H'
    keep-tex: true
    cite-method: natbib
    include-in-header: 
      - "WPROJ.sty"
    include-before-body:
      - "coversheet.tex"
    toc: true
    embed-resources: true
    number-sections: true
  html:
    toc: true
    embed-resources: true
    number-sections: true
    cite-method: natbib
    include-in-header: 
      - "WPROJ.sty"
    include-before-body:
      - "coversheet.tex"
execute:
  fig-format: png
  dpi: 300
  warnning: false

fontsize: 12pt
linestretch: 2
bibliography: references.bib

editor: source
---

```{r setup}
#| include: false
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
setwd("~/DeVries_WP/")
library(rpart)
library(rpart.plot)
library(ggplot2)
library(tidyverse)
library(plotly)
library(ggpubr)
library(randomForest)
library(fields)
library(mnormt)
library(DiagrammeR)
library(future)
library(future.apply)
library(BART)
library(matrixStats)
library(ggnewscale)
library(raster)
library(bartMan)
library(sf)
library(geojsonsf)
library(scoringRules)
set.seed(406)
```

\newpage

# Introduction {#sec:intro}

\citep{encyclo} tells us a flying fox is a large type of fruit bat. There are about 65 species found on tropical islands from Madagascar to Australia and Indonesia, as well as in parts of mainland Asia. Our interest in flying foxes stems from the Hendra virus, which is endemic to the four species of flying foxes in Australia. This rare virus is zoonotic, meaning it can be transferred from animals to humans. There is a fairly low chance of a bat transmitting Hendra virus to a person. Humans infected with Hendra virus have come into contact with horses exposed to waste/bodily fluids from flying foxes. In Pathogen Spillover Driven By Rapid Changes in Bat Ecology, \citep{andy_art} identified loss of flying fox habitat and climate as influential factors in Hendra virus spillovers. Loss of habitat and climate both effect the availability of food and water, leading bats to venture into farmland. In this project we explore potential associations between land cover and flying fox feeding locations. To assess the impact of land cover on feeding locations, we apply \citep{bart_paper} Bayesian Additive Regression Trees (BART). A large portion of this project is devoted to learning about tree algorithms, and tools used to work with spatial data.

In traditional regression models we assume some sort of relationship between the response, variables of interest, and controlling factors. Exploratory data analysis, background information, and model experimentation can bring light to potential relationships, but many problems involve unobservable dynamics that are difficult or impossible to capture via a linear model. In some cases it is often necessary to take a more algorithmic approach to modelling. Unfortunately, many models in the algorithmic framework are referred to as black boxes, indicating the inner workings of a fitted model are difficult or impossible to explain in a meaningful way. Decision tree ensembles sit within the black box framework, but the explainability of individual trees has lead to establishing variable importance and interaction measures along with other useful tools for inference. It is still very difficult to interpret the effects of individual predictors in these models, as the hierarchical structure can make marginal effects very missleading. Still, variable importance measures combined with predictive accuracy make ensembles of trees a great tool for exploratory analysis. Our project starts with a brief review of supervised learning before discussing Classification and Regression Trees (CART) \citep{cart} along with several models inspired by CART. Next, our attention shifts to tools for obtaining and preparing data for our analysis. In this project we use Google Earth Engine to obtain our covariates, and access the response from an archived PostgreSQL database. Finally, we apply BART to analyze the feeding locations of flying foxes and assess the predictive accuracy of our model.

# Background {#sec:background}

## Supervised Learning


With this project, we chose to focus on tree based methods. The Elements of Statistical Learning \citep{esl} was a key source for understanding algorithms and concepts in statistical learning. Our background discussion begins with some notation and concepts in supervised learning. We then discuss the algorithms for several models, using simulation to demonstrate there use. In supervised learning problems we work to map a set of features to a target. When discussing these components, we'll follow the notation used in The Elements of Statistical Learning \citep{esl}. $X$ denotes the features while $Y$ and $G$ denote the target for quantitative and categorical responses respectively. If there are $N$ observations of $p$ inputs, then $\bm X$ is an $N\times p$ matrix. The inputs for the $i$'th observation are $\bm x_i$ while $\bm x_j$ denotes the vector of all observations for the $j$'th feature.

A common approach in supervised learning is to assume our features and target are observation of random variables with joint distribution $\text{Pr}(Y,X)$. $G$ would replace $Y$ in a classification problem and $\bm X$ would replace $X$ for multiple covariates. We want to find a function $f:\mathcal{X}\rightarrow\mathcal{Y}$ that predicts $Y$ reasonably well. To do this, we define a loss function $L(Y,f(X))$ which penalizes the prediction error on a training set $\boldsymbol \tau=(\bm x_1,y_1),...,(\bm x_N,y_N)$. The expected prediction error (EPE) is defined as $\mathbb{E}[L(Y,f(X))]$. Our overall goal is to approximate the function $f$ that minimizes the EPE. Using squared errors for loss $(L_2)$, the EPE is minimized by choosing $f$ such that $f(x)=\mathbb{E}[Y|X=x]$ (The Elements of Statistical Learning, pg. 18 \citep{esl}). Now we need an algorithm to approximate $f$ using $\boldsymbol \tau$. Choosing an appropriate algorithm will be heavily influenced by the availability and distribution of data. With a quantitative target, we might be able to assume an additive error relationship between $Y$ and $\bm X$.

The additive error model is simply $Y=f(\bm X)+\epsilon$ where $\mathbb{E}[\epsilon]=0$ and $\bm X\perp\epsilon$. Here we are assuming the process that generated $Y$ can be approximated using $\bm X$ such that the error due to ignored features and other factors has mean zero. For data that was generated under an additive error model, a natural approach to approximate $f$ is to use a sum of basis functions. The additive model is defined as $Y=\beta_0+\sum_{j=1}^pf_j(\bm x_j)+\epsilon$. In this model, each $f_j$ could be a sum of basis functions. The major limitation to an additive model is we assume no interactions between features. There's no reason we can't add interactions or functions of multiple covariates, but identifying these interactions is difficult. We might be able to fit a model with select transformations of covariates and every possible interaction, but this would almost certainly result in overfitting. Assuming a generating model with any form of noise implies even the optimal $f$ will not predict every observation perfectly. A model is overfit when trends are ignored to explain slight irregularities in a sample. Discerning irregularities is highly subjective. Any decision we make based on observed data may lead to overfitting. To compare models predictive capability, we use data that has been held out from training to obtain a sample of prediction errors. With this sample, we can use some metric (usually based on our loss function) for model validation.

There are a variety of methods to perform model validation, but the two most common are hold out and K-fold. In hold out, some portion of the data is held out for testing and the rest is used to fit the model. If the model contains hyper parameters, we could split the data into training, validation, and testing. Fitting models to the training set, we can try various values for hyper parameters and compare model performance for predictions on the validation set. After we determine the optimal hyper parameter values, we refit the model on the combined training and validation set before using the testing set to assess the final fit. In some cases, additional tuning may be required after combining training and validation as additional training data may change the optimal values of hyperparameters. Using training/testing splits is generally favored for computationally intensive problems with observations to spare. The primary disadvantage to hold out validation is we can't use as much data for training.

In K-fold cross validation, we get to train and test using all available data by first splitting the data into $k$ folds of size $\approx N/k$. One fold is held for testing and $k-1$ are used for training. This is then repeated until all folds have been tested. A metric can be then used to select the model before fitting it to the complete dataset. K-fold makes the most of the available data, but is more computationally expensive. Additionally, K-fold does not assess the final model fit as parameter estimates will change as the model is refit. For models with low variance, representativeness of the available data is really the only concern. If there is a lot of variation in estimated parameters across folds, our cross validation becomes more of an assessment of the theoretical as opposed to fit model. This can still useful for model selection and refinement.

## Decision Trees

Decision trees are a type of hierarchical model where the the feature space is partitioned into hyperrectangular regions, and a model is fit for each region. For regression tasks, we typically use mean only models. In this case the decision tree model is a step function. Unlike our mean only models for linear regression, we do not make any distributional assumptions. Without a distribution, we can't quantify the uncertainty in our predictions. Additionally, the binary structure of trees changes the interpretation of effects. Small changes in a continuous feature $x_{i,j}$ may not effect the associated prediction $\hat y_i$. The mathematical relationship defining a linear model is highly informative, but rather rigid. Trees greatly outperform linear models with more complex data. A hierarchical structure naturally handles multicollinearity, and can help us find interactions between covariates. Even though we don't believe $\bm X$ is related to $\bm y$ by a step function, we can gain insight to the true relationship by a step function approximation. An example of a tree model is shown in @fig-tree-examp. Every decision after the top root node is conditioned on the previous decisions, allowing us to display the hierarchy graphically.

```{mermaid}
%%| label: fig-tree-examp
%%| fig-cap: Visualization of binary decision tree

flowchart TD
  A["$$X_1\ge a$$"]
  A --> |Yes| B["$$X_2\ge b$$"]
  A --> |No| C["$$X_3\ge c$$"]
  B --> |Yes| D("$$\mu_1$$")
  B --> |No| E("$$\mu_2$$")
  C --> |Yes| F["$$X_2\ge d$$"]
  C --> |No| G("$$\mu_3$$")
  F --> |Yes| H("$$\mu_4$$")
  F --> |No| I("$$\mu_5$$")
```

Step functions are very flexible and for any training set $\bm X$ with target $Y$ where $y_i|\bm X_i= y_j|\bm X_i$ for all $i,j$, we can fit a tree that will have no error on the training set. With this flexibility, over fitting is a major concern. We can control the overall size and shape of trees with three hyper-parameters. First is the complexity parameter $\alpha$. $\alpha$ scales the penalty which is based on the number of terminal nodes (mean only models). Next we have the minimum split and minimum bucket sizes. The minimum bucket is the fewest number of observations allowed in a terminal node. Similarly, the minimum split is the least number of observations allowed in one outcome of a binary decision. We generally choose the complexity parameter by growing the largest possible tree, then removing terminal nodes with fewer observations. Next we compare the trees via cross validation and choose the tree with minimal cross validated error. This process of choosing an appropriate tree size is commonly referred to as pruning. While pruning helps reduce the risk of over fitting, large regression trees are inherently unstable. We'll demonstrate this with data simulated under the model described below. The rpart function developed by \citep{rpart} is used to fit our CART model. A simulated testing data set displaying the true function along with the fit from a tree chosen by cross validation on training is displayed in @fig-sim1-pred-vis. @fig-sim1-tree displays the number of splits for the optimal number of splits chosen by cross validation. $$y_i=\cos(108t_i\sin(108t_i+w_i))\cdot\exp(\sin(108t_i\cos(108t_i+x_i)))+z_i$$ $$W_i,X_i,Z_i\sim N(0,\sigma^2)$$ $$t_i=-\frac{\pi}{18},...,\frac{\pi}{18}$$ $$i=1,2,...,350$$

```{r cache=TRUE}
#| label: fig-sim1-pred-vis
#| fig-cap: Visualization of simulated data and predictions
#| echo: FALSE
#| cache: true

set.seed(123)
i <- seq(-pi / 18, pi / 18, 0.001)
noise <- 0.3
x <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
y <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)

true0 <- data.frame(
  x = x,
  y = y,
  z = cos(x) * exp(sin(y)) + rnorm(length(i), 0, noise)
)

x <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
y <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)
xnn <- 108 * i * sin(i * 108)
ynn <- 108 * i * cos(i * 108)
znn <- cos(xnn) * exp(sin(ynn))

true1 <- data.frame(
  x = x,
  y = y,
  z = cos(x) * exp(sin(y)) + rnorm(length(i), 0, noise)
)

ran0 <- randomForest(data = true0, z ~ i, ntree = 250)
tree0 <- rpart(data = true0, z ~ i,
               control = rpart.control(minsplit = 1, minbucket = 1, cp = 0))
opt_i <- which(tree0$cptable[, 4] == min(tree0$cptable[, 4])) |> as.vector()
if (length(opt_i) != 1) {
  opt_i <- opt_i[which(tree0$cptable[opt_i, 2] == min(tree0$cptable[opt_i, 2]))]
}
tree1 <- rpart(data = true0, z ~ i,
               control = rpart.control(minsplit = 1, minbucket = 1,
                                       cp = tree0$cptable[opt_i, 1]))
func_dat <- data.frame(y = true0$z, i = i, Forest = predict(ran0, newdata = true1),
                       Tree = predict(tree1, newdata = true1))
quant_theme <- theme(panel.background = element_rect(fill = "white"),
        panel.grid = element_line(colour = "grey"),
        legend.position = c(0.9, 0.1),
        legend.background = element_blank())

ggplot(func_dat) +
  geom_line(aes(x = i, y = znn, color = "True Function")) +
  geom_line(aes(x = i, y = Tree, color = factor("Tree"))) +
  geom_point(aes(x = i, y = z), alpha = 0.2, color = "darkgreen",
             data = true0) + 
  scale_color_manual(
    values = c("Tree" = "orange", "True Function" = "darkgreen"),
    name = ""
  ) +
  quant_theme +
  labs(y = "y", x = "t", title = "CART Fit on Simulated Dataset")

# ggplot(func_dat) +
#   geom_line(aes(x = i, y = znn, color = "True Function")) +
#   geom_line(aes(x = i, y = Forest, color = factor("Forest"))) +
#   geom_line(aes(x = i, y = Tree, color = factor("Tree"))) +
#   geom_point(aes(x = i, y = z), alpha = 0.2, color = "darkgreen",
#              data = true0) + 
#   scale_color_manual(
#     values = c("Forest" = "orange", "Tree" = "red", "True Function" = "darkgreen"),
#     name = ""
#   ) +
#   quant_theme +
#   labs(y = "y", x = "t",
#        main = "Random Forest")
```

```{r cache=TRUE}
#| label: fig-sim1-tree
#| fig-cap: Violin plots of optimal number of splits for simulated data
#| echo: FALSE
#| cache: true

noises <- rep(c(0.1, 0.15, 0.2), each = 100) |> matrix()
sim_res <- apply(noises, 1, function(noise) {
  x <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
  y <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)
  train <- data.frame(
    x = x,
    y = y,
    z = cos(x) * exp(sin(y)) + rnorm(length(i), 0, noise),
    i = i
  )
  x <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
  y <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)
  test <- data.frame(
    x = x,
    y = y,
    z = cos(x) * exp(sin(y)) + rnorm(length(i), 0, noise),
    i = i
  )
  tree0 <- rpart(data = train, z ~ i, control =
                   rpart.control(minsplit = 1, minbucket = 1, cp = 0))
  opt_i <- which(tree0$cptable[, 4] == min(tree0$cptable[, 4])) |>
    as.vector()
  if (length(opt_i) > 1) {
    opt_i <- min(opt_i)
  }
  tree1 <- rpart(data = train, z ~ i, control =
                   rpart.control(minsplit = 1, minbucket = 1,
                                 cp = tree0$cptable[opt_i, 1]))
  
  return(c(tree0$cptable[opt_i, c(1, 2, 4)], noise,
           mean((test$z - predict(tree1, newdata = test)) ^ 2)))
}) |> t() |> as.data.frame()

sim_res <- sim_res |> dplyr::rename("Sigma" = "V4")


sim_theme <- theme(axis.ticks.x = element_blank(),
        panel.grid = element_blank(),
        panel.background = element_blank(),
        strip.background.x = element_blank(),
        legend.position = "none")

ggplot(sim_res) +
  geom_violin(aes(x = factor(Sigma), y = nsplit, fill = Sigma, group = Sigma)) +
  sim_theme +
  scale_fill_gradient(low = "darkgreen", high = "gold3") +
  labs(x = "Standard Deviation of Noise (Sigma)",
       y = "Optimal Number of Splits",
       title = "Optimal Number of Splits Chosen by Cross Validation")
```

Decision trees are very unstable for this data. Across all three noise levels, the number of splits chosen by cross validation ranges from zero to over 300. The variability in the size/structure of trees suggest we can't have much faith in predictions from an individual tree. A simpler model will be less variable, but more biased. To maintain low bias and reduce variance, we turn our attention to ensemble methods. Ensemle methods are quite prevalent in predictive modelling. By combining the predictions from several models, we can reduce the variance of predictions while capturing complex intricacies of the data.

The Random Forests algorithm, developed by \citep{random_forest}, is a CART-based ensemble combining Bootstrap Aggregating (Bagging) \citep{bagging} and Hoâ€™s Random Decision Forests \citep{Ho}. Bagging is simply averaging the predictions of models fit to bootstrapped samples. When possible, we obtain $\hat y_i$ from averaging trees where $\bm x_i$ did not appear in training. These predictions are reffered to as "out of bag predictions". Cross validation on out of bag predictions is not required as they are not based on the observed values of $\bm x_i$.

On pages 271-272 of Elements of Statistical Learning, \citep{esl} show that the distribution of bootstrap means for infinite samples from a normal population is equivalent to to the Bayesian posterior distribution with a non-informative prior. They also demonstrate that for the multinomial likelihood, the bootstrap distribution with infinite draws from the population approximates the Bayesian posterior assuming all outcomes are equi probable apriori. Later on pages 282-288, \citep{esl} show that the MSE of bagged estimates where samples are drawn from the population is less than or equal to the MSE of an indvidual model. For classification problems, \citep{bagging} shows that with infinite samples from the population, bagging can approximate the optimal classifier under certain conditions. This requires the majority of classifiers fit to bootstrapped samples to predict the correct class more often than not and relatively balanced classes. Otherwise, bagging can make classifiers worse. All of these results concerning infinite samples are not very useful, but hint at the practical applications of bagging.

The main limitation in bagging alone is correlation between models. If we think about averaging results from two trees $T_1,T_2$ for predictions, the variance of our estimates will be $\frac{1}{4}(\mathbb{V}[T_1]+\mathbb{V}[T_2]+2\cdot\text{cov}(T_1, T_2))$. When only a few variables contain relevant information, we expect trees to make similar predictions. The Random forests algorithm of \citep{random_forest} combats the correlation between trees by taking the same approach implemented by Ho in Random decision forests \citep{Ho}. Random decision forests average multiple decision trees fit to the same data. The key feature in the algorithm is the random subspace method where a random subset of the available predictors is drawn for each decision. Introducing randomness brings variety to the forest, resulting in weaker correlation between trees. The combination of random subspace and bagging makes Breiman's Random forest \citep{random_forest} a flexible model with low variance. The hyperparameters for the random forest model are the number of trees to grow, the minimum and maximum number of observations allowed in a terminal node, and the number of predictors to select for each decision. In @fig-sim1-mse we compare the MSE of models fit to data simulated in the same way as the previous simulation study. The rpart \citep{rpart} and randomForest \citep{rf_r} functions were used to fit models.

```{r}
#| label: fig-sim1-rf-fit
#| fig-cap: Violin plots of MSE for tree and forest models on simulated data
#| echo: FALSE
#| cache: true

ggplot(func_dat) +
  geom_line(aes(x = i, y = znn, color = "True Function")) +
  geom_line(aes(x = i, y = Forest, color = factor("Forest"))) +
  geom_point(aes(x = i, y = z), alpha = 0.2, color = "darkgreen",
             data = true0) + 
  scale_color_manual(
    values = c("Forest" = "orange", "True Function" = "darkgreen"),
    name = ""
  ) +
  quant_theme +
  labs(y = "y", x = "t", title = "Random Forest")
```

```{r cache=TRUE}
#| label: fig-sim1-mse
#| fig-cap: Violin plots of MSE for tree and forest models on simulated data
#| echo: FALSE
#| cache: true

sim_res_forest <- apply(noises, 1, function(noise) {
  x <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
  y <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)
  train <- data.frame(
    x = x,
    y = y,
    z = cos(x) * exp(sin(y)) + rnorm(length(i), 0, noise),
    i = i
  )
  x1 <- 108 * i * sin(i * 108) + rnorm(length(i), 0, noise)
  y1 <- 108 * i * cos(i * 108) + rnorm(length(i), 0, noise)
  test <- data.frame(
    x = x1,
    y = y1,
    z = cos(x1) * exp(sin(y1)) + rnorm(length(i), 0, noise),
    i = i
  )
  ran0 <- randomForest(data = train, z ~ i)
  return(c(mean((test$z - predict(ran0, newdata = test)) ^ 2), noise))
    
}) |> t() |> as.data.frame() |> dplyr::rename("Sigma" = "V2")

mse_both <- data.frame(MSE = c(sim_res_forest$V1, sim_res$V5),
                       Sigma = c(sim_res_forest$Sigma, sim_res$Sigma),
                       Sigma1 = c(sim_res_forest$Sigma, sim_res$Sigma),
                       Model = rep(c("Random Forest", "Decision Tree"),
                                   each = 300))

ggplot() +
  geom_violin(aes(x = factor(Sigma), y = MSE, fill = Sigma, group = Sigma),
              data = mse_both |> filter(Model == "Decision Tree"), alpha = 0.5) +
  scale_fill_gradient(name = "Noise For\nDecision Tree", low = "lightgreen", high = "gold3") +
  new_scale_fill() +
  geom_violin(aes(x = factor(Sigma), y = MSE, fill = Sigma1, group = Sigma1),
              data = mse_both |> filter(Model == "Random Forest"), alpha = 0.5) +
  scale_fill_gradient(name = "Noise For\nRandom Forest", low = "darkgreen", high = "sienna") +
  sim_theme +
  theme(legend.position = "bottom",
        legend.text = element_blank()) +
  labs(x = "Standard Deviation of Noise and Model Type",
       y = "MSE on New Dataset",
       title = "MSE from Random Forest and Decision Tree Models on\nTesting Data")

```

We see considerably less variation in the mean squared error of random forests fit to the same data as individual decision trees, but single tree models generally outperformed a random forest. Random forests are designed for data with several covariates. With a single predictor, the random forest algorithm degenerates to bagging with out of bag predictions. Bagging reduces the variance of predictions at the cost of bias, and thus the "random forest" predictions were often worse than predictions from individual trees. Pages 600, 601 of The Elements of Statistical Learning, \citep{esl} display a proof showing that the bias of a random forest is the same as the bias of any individual tree in the ensemble. The randomization in the random forest algorithm implies trees within the ensemble are almost certainly smaller than a single tree fit to the data. In cases where we have access to several predictors, large trees will create complex hierarchies that are unlikely to exist in the true model. The following simulation study shows the random forest algorithm consistently outperform a single tree for data generated under a linear model with correlated covariates. Violin plots of MSE on testing data are displayed in @fig-sim2.

```{r cache=TRUE, warning=FALSE}
#| label: fig-sim2
#| fig-cap: Violin plots of MSE for tree and forest models on linear model with several predictors
#| echo: FALSE
#| cache: true

plan(multisession)
coords <- expand.grid(seq(0, 9), seq(0, 9))
dists <- dist(coords, diag = T, upper = T) |> 
  as.matrix(nrow = 10, ncol = 10)
sig <- Matern(dists, range = 1, phi = 10, smoothness = 2)
beta <- apply(as.matrix(1 : 50), 1, function(a) {return(c(rnorm(1, 1, 5),
                                                          rnorm(1, -1, 5)))}) |> 
  as.vector()

sim2_res <- future_apply(matrix(1 : 100), 1, function (a) {
  X_T1 <- rmnorm(500, mean = seq(3, 10, length.out = 100), varcov = sig)
  X_V1 <- rmnorm(500, mean = seq(3, 10, length.out = 100), varcov = sig)
  X_T2 <- X_T1[, 1 : 50]
  X_V2 <- X_V1[, 1 : 50]
  X_T3 <- X_T1[, 1 : 25]
  X_V3 <- X_V1[, 1 : 25]
  X_T4 <- X_T1[, 1 : 4]
  X_V4 <- X_V1[, 1 : 4]
  Y_T1 <- X_T1 %*% beta + rnorm(500, 0, 1)
  Y_V1 <- X_V1 %*% beta + rnorm(500, 0, 1)
  Y_T2 <- X_T2 %*% beta[1 : 50] + rnorm(500, 0, 1)
  Y_V2 <- X_V2 %*% beta[1 : 50] + rnorm(500, 0, 1)
  Y_T3 <- X_T3 %*% beta[1 : 25] + rnorm(500, 0, 1)
  Y_V3 <- X_V3 %*% beta[1 : 25] + rnorm(500, 0, 1)
  Y_T4 <- X_T4 %*% beta[1 : 4] + rnorm(500, 0, 1)
  Y_V4 <- X_V4 %*% beta[1 : 4] + rnorm(500, 0, 1)
  X_V1 <- X_V1 |> as.data.frame()
  X_V2 <- X_V2 |> as.data.frame()
  X_V3 <- X_V3 |> as.data.frame()
  X_V4 <- X_V4 |> as.data.frame()

  tree0_100 <- rpart(formula = Y_T1 ~ X_T1, control =
                 rpart.control(cp = 0, minsplit = 1, minbucket = 1))
  opt100 <- which(tree0_100$cptable[, 4] == min(tree0_100$cptable[, 4])) |>
    as.vector()
  if (length(opt100 > 1)) {
    opt100 <- min(opt100)
  }
  tree1_100 <- rpart(formula = Y_T1 ~ X_T1, control =
                 rpart.control(cp = tree0_100$cptable[opt100, 1],
                               minsplit = 1, minbucket = 1))
  tree0_50 <- rpart(formula = Y_T2 ~ X_T2, control =
                 rpart.control(cp = 0, minsplit = 1, minbucket = 1))
  opt50 <- which(tree0_50$cptable[, 4] == min(tree0_100$cptable[, 4])) |>
    as.vector()
  if (length(opt50) != 1) {
    opt50 <- opt50[which(tree0_50$cptable[opt50, 2] ==
                           min(tree0_50$cptable[opt50, 2]))]
  }
  tree1_50 <- rpart(formula = Y_T2 ~ X_T2, control =
                 rpart.control(cp = tree0_50$cptable[opt50, 1],
                               minsplit = 1, minbucket = 1))
  tree0_25 <- rpart(formula = Y_T3 ~ X_T3, control =
                 rpart.control(cp = 0, minsplit = 1, minbucket = 1))
  opt25 <- which(tree0_25$cptable[, 4] == min(tree0_25$cptable[, 4])) |>
    as.vector()
  if (length(opt25) != 1) {
    opt25 <- opt25[which(tree0_25$cptable[opt25, 2] == 
                           min(tree0_25$cptable[opt25, 2]))]
  }
  tree1_25 <- rpart(formula = Y_T3 ~ X_T3, control =
                 rpart.control(cp = tree0_25$cptable[opt25, 1],
                               minsplit = 1, minbucket = 1))
  tree0_4 <- rpart(formula = Y_T3 ~ X_T3, control =
                 rpart.control(cp = 0, minsplit = 1, minbucket = 1))
  opt4 <- which(tree0_4$cptable[, 4] == min(tree0_4$cptable[, 4])) |> as.vector()
  if (length(opt4) != 1) {
    opt4 <- opt4[which(tree0_4$cptable[opt4, 2] ==
                           min(tree0_4$cptable[opt4, 2]))]
  }
  tree1_4 <- rpart(formula = Y_T4 ~ X_T4, control =
                 rpart.control(cp = tree0_4$cptable[opt4, 1],
                               minsplit = 1, minbucket = 1))
  
  
  ran_100 <- randomForest(x = X_T1, y = Y_T1, ntree = 800, importance = T)
  ran_50 <- randomForest(x = X_T2, y = Y_T2, ntree = 800, importance = T)
  ran_25 <- randomForest(x = X_T3, y = Y_T3, ntree = 800, importance = T)
  ran_4 <- randomForest(x = X_T4, y = Y_T4, ntree = 800, importance = T)
  
  return(c(mean((Y_V4 - predict(tree1_4, newdata = X_V4)) ^ 2),
           mean((Y_V3 - predict(tree1_25, newdata = X_V3)) ^ 2),
           mean((Y_V2 - predict(tree1_50, newdata = X_V2)) ^ 2),
           mean((Y_V1 - predict(tree1_100, newdata = X_V1)) ^ 2),
           mean((Y_V4 - predict(ran_4, newdata = X_V4)) ^ 2),
           mean((Y_V3 - predict(ran_25, newdata = X_V3)) ^ 2),
           mean((Y_V2 - predict(ran_50, newdata = X_V2)) ^ 2),
           mean((Y_V1 - predict(ran_100, newdata = X_V1)) ^ 2)))
}, future.seed = 252) |> t()
sim_dat <- data.frame(y = c(sim2_res), 
                 x = rep(c(paste("Tree w/", c(4, 25, 50, 100),
                                 "Predictors"),
                           paste("RF w/", c(4, 25, 50, 100),
                                 "Predictors")),
                         each = 100)) |> as.data.frame()
ggplot(data = sim_dat) +
  geom_jitter(aes(y = y, x = x, , color = x), alpha = 0.2) +
  sim_theme +
  theme(axis.text.x.bottom = element_text(), legend.position = "none") +
  coord_flip() +
  labs(y = "MSE", x = "",
       title = "MSE for Random Forest (RF) and Individual Tree Models on Testing
Data Simulated from Linear Model With\nMulticollinearity Present")
plan(sequential)
```

## Bayesian CART

In the current and following section we discuss Bayesian methods for tree algorithms. Bayesian tree algorithms assume a stochastic process generates the tree, and a distribution for the observations within the terminal nodes. Randomness is used to explore possible structures that may increase the likelihood. The flexibility of trees necessitates regularization of their structure, which can be easily achieved through the use of a prior. There are many ways to specify a Bayesian tree but, our discussion is limited to the Bayesian CART method proposed by \citep{bayes_cart}. In Bayesian CART, the search process begins with an inital stump tree, and proposes a new structure for the tree at random. For the proposal, there are four possibilities. A change step is proposed with probability 0.4. In the change step, a non-terminal node is randomly selected and the splitting rule replaced. The new rule is chosen by randomly selecting a splitting variable $X_j$, and then randomly selecting an observed value of $\bm x_j$ as a cutoff. The same splitting rule cannot appear multiple times within the current tree. For the grow step of the search, a terminal node is randomly selected, a splitting rule is added, and a sibling for the chosen node is grown. The probability a grow step is 0.25 and the decision rule is chosen in the same way as in the change step. The third possible move in the search is randomly selecting intermediate nodes, and collapsing all nodes beneath. This step is referred to as pruning and is proposed with probability 0.25. The last possible move for a trees structure is node swapping. Parent and child intermediate nodes are selected and the rules are swapped. After updating the structure of the tree, new nodes are marked as splittable with probability $\frac{\alpha}{1+\beta\gamma^d}$ where $\alpha\in(0,1)$ and $\beta,\gamma\in(0,\infty)$ are hyperparameters and $d$ is the depth of the selected node. Finally, terminal nodes are updated and the proposal is accepted or rejected. \citep{bayes_cart} describe methods for independent and correlated terminal nodes. With the proposal tree constructed, the Metropolis-Hastings algorithm is used to update the sequence of trees.

Bayesian CART may become stuck around a local mode where the next tree in the sequence provides little to no improvement. To combat this, a sequence of trees is generated until the change in posterior probability between trees in the sequence stabilizes. The algorithm is then restarted to search for another local mode. Convergence is tracked by comparing the posterior probability distribution of a tree to it's predecessors, keeping track of which trees have the highest probability. The frequency of tree structures explored is ignored, making Bayesian CART a stochastic search as opposed to a Monte Carlo based method like in BART. Averaging trees that have converged to a local mode results in a model similiar to random forests. Unlike random forests there is a distribution for the predictions.

## Bayesian Additive Regression Trees (BART)

The other learning algorithm we explored was BART, or Bayesian Additive Regression Trees. For a continuous predictor, BART assumes $y_i\sim N(\sum_{b=1}^m g(\bm x_i;T_b,M_b), \sigma^2)$ where $T_b$ is the $b$'th tree, $M_b$ are the associated terminal nodes, and $g(\bm x_i;T_b,M_b)$ is the function that assigns $\bm x_i$ to $\mu_{lb}$, $l\in\{1,2,...,|M_b|\}$. Unlike the random forest algorithm, the trees are not bagged and each tree has access to each feature. Additionally, the final model is based on the sum of all trees as opposed to an average. A key difference between the approach to growing trees in BART and Bayesian CART is that the BART tree structure is grown via MCMC as opposed to a Markov chain stochastic search. Using a highly informative prior encourages smaller trees, resulting in faster convergence and less variable predictions.

The algorithm starts by growing $M$ trees with a single terminal node (stumps). Gibbs sampling is used to iteratively update each tree conditioned on all other trees. Conditional updates are simplified by expressing $T_b|T_1,T_2,...T_{b-1},T_{b+1},...T_m$ as $T_b|R_b$ where $R_b$ denotes the distribution of residuals from predictions excluding $T_b$. Summing trees grown conditionally on one another makes the contributions of individual nodes small. \citep{bart_paper} state "... we can imagine the algorithm as analogous to sculpting a complex figure by adding and subtracting small dabs of clay." This incremental sculpting process is achieved by using a highly informative prior, also preventing any single tree from dominating the model.

BART is an adaptation of there original Bayesian CART algorithm \citep{bayes_cart}. With the smaller tree sizes, the pruning proposal is modified to only prune terminal nodes. Even with this modification, trees will still collapse to a stump throughout MCMC. Convergence is aided by the somewhat unrealistic assumption of independent priors for each tree and the standard deviation. The joint prior is given by $$p((T_1, M_1), (T_2, M_2),...,(T_m, M_m),\sigma^2)=p(\sigma^2)\prod_{b=1}^mp(M_b|T_b)p(T_b)$$ where $p(M_b|T_b)=\prod_{l=1}^{|M_b|}p(\mu_{lb}|T_b)$, and $p(\sigma^2)\sim\nu\lambda/\chi^2_\nu$ with hyperparameters $\nu,\lambda$. The hyper parameters are selected by first choosing a point estimate $\hat\sigma$. By default, this is the residual standard deviation for a multiple linear regression model. $\nu$ is then fixed ($\nu\in[3,10]$ recommended) and $\lambda$ solved for by imposing the constraint $\text{Pr}(\sigma<\hat\sigma)=q$, where $q$ is an additional hyper parameter. In the prior for a tree $p(T_b)$, the probability that a node at depth $d\in\mathbb{N}$ is non-terminal is given by $\alpha(1+d)^{-\beta}$, $\alpha\in(0,1),\ \beta\in[0,\infty)$. A discrete uniform prior imposes the initial belief that each feature equally likely to be selected for a nodes splitting rule. Similarly, a discrete uniform across the observed values of the selected predictor serves as the prior for the cut point in the binary decision. A $N(|M|\mu_\mu,|M|\sigma^2_\mu)$ prior is assumed for each $\mu_{lb}|T_b$ where $|M|$ is the total number of terminal nodes across all trees. The hyperparameters $\mu_\mu$ and $\sigma_\mu$ are chosen based on the data such that $\min(Y)=|M|\mu_\mu-k\sqrt{|M|}\sigma_\mu$ and $\max(Y)=|M|\mu_\mu-k\sqrt{|M|}\sigma_\mu$. In \citep{bart_paper}, they recommend choosing $k\in[1,3]$. The BART R package \citep{bart_r} resales $Y$ such that $Y\in[-0.5, 0.5]$ and chooses $\mu_\mu=0\implies\sigma_\mu=\frac{0.5}{k\sqrt{|M|}}$.

Two differences between BART and traditional Bayesian models are the number of trees $m$ is fixed and data is used to inform the priors. These features push BART to be more of a non-parametric method, but with many of the features of Bayesian models. Inference is still derived from the likelihood and hyperparameters can be tuned using a testing set with the goal of bringing prediction intervals to the nominal level. An example of a BART model tuned for nominal coverage to simulated data is displayed in @fig-bart-sim1. The poor fit can likely be explained by non-additive noise in the generating function. BART is incredibly, flexible but at the end of the day it is still an additive model.

```{r}
#| echo: FALSE
#| output: FALSE
#| include: FALSE
#| eval: false

n <- 250
X <- runif(n * 6, -5, 5) |> matrix(ncol = 6) |> data.frame()
pairs <- list(c(1, 6), c(1, 2), c(1, 3), c(2, 6))
y <- rowSums2(sapply(pairs, function(a) sqrt(abs((X[, a[1]] * X[, a[2]]))))) +
  sin(X[, 1]) + cos(X[, 2]) + log(abs(X[, 3])) + X[, 4] ^ 2 +
  floor(X[, 5]) + ceiling(X[, 6]) + rnorm(n)

m_bart <- wbart(x.train = X, y.train = y, 
                ntree = 49, ndpost = 1500, nskip = 1500)
bartDiag(m_bart, response = y, data = X)

bart_dat <- extractTreeData(m_bart, data = X)
vsupMat <- viviBartMatrix(bart_dat,
                          type = 'vsup',
                          metric = 'propMean',
                          metricError = "CV")
viviBartPlot(vsupMat,
             max_desat = 1,
             pow_desat = 0.6,
             max_light = 0.6,
             pow_light = 1,
             label = 'Coeff. of Variation') +
  ggtitle("Variable Importance and Interaction Measures Example")

plotTrees(bart_dat, iter = 1) +
  ggtitle("Structure of Trees for First Iteration After Burn")
```

```{r}
#| echo: FALSE
#| include: FALSE
#| output: false
#| cache: true

post0 <- wbart(x.train = true0$x, y.train = true0$z,
               x.test = true1$x, ntree = 250, cont = T, k = 0.5, lambda = 220,
               base = 0.99, power = 0.5, sigquant = 0.99, sigest = 2 * sd(true0$y))
pred <- predict(post0, newdata = matrix(true1$x))
pred_quants <- colQuantiles(pred, probs = c(0.025, 0.975))

mean(between(true1$z, pred_quants[, 1], pred_quants[, 2]))

mean((true1$z - pred_quants[, 2]) ^ 2)
mean((true1$z - predict(ran0, newdata = true1$z)) ^ 2)
```

```{r}
#| label: fig-bart-sim1
#| fig-cap: Visualization of bart
#| echo: false
#| cache: true

ggplot() +
  geom_ribbon(aes(x = i, ymin = pred_quants[, 1], ymax = pred_quants[, 2],
                  fill = "95% PPI"), alpha = 0.5) +
  geom_line(aes(x = i, y = colMeans(pred), color = "BART Mean")) +
  geom_line(aes(x = i, y = znn, color = "True Function"), alpha = 0.9) +
  geom_point(aes(x = i, y = z), alpha = 0.2, color = "darkgreen", data = true0) + 
  quant_theme +
  theme(
    legend.position = c(0.85, 0), 
    legend.spacing.x = unit(0.1, "cm"),
    legend.box = "horizontal"
  ) +
  scale_color_manual(
    values = c("BART Mean" = "magenta", "True Function" = "darkgreen"), 
    name = ""
  ) +
  scale_fill_manual(
    values = c("95% PPI" = "gold"),
    name = ""
  ) +
  labs(y = "y", x = "t", title = "BART Fit Example")
```

So far we have focused on BART and other algorithms ability to estimate functions. Ensembles of trees are not used exclusively for prediction. Two inferential tools that are commonly used with both random forests and BART are variable importance and variable interaction measures. We briefly describe these measures, using \citep{bartMan} bartMan R package. Notes on variable importance and variable interaction measures are based on the documentation. Similiar measurements have been useful for inference from random forests, but the calculations are different.

Variable importance can be measurd by looking at the proportion of decisions in which a variable is used. For BART, the structure of the trees varies across iterations of MCMC, so we define $c_{r,k}$ as the number of times variable $r$ is used as a splitting decisions within the $k'$th posterior sample. $c_k=\sum_{j=1}^Pc_{r,k}$ is thus the total number of decisions for the $k'$th posterior sample. Variable importance is then measured as $\text{VImp}_r=\sum_{k=1}^K\frac{c_{r,k}}{c_k}$. Thinking of the extreme cases, with covariates that provide no information about the response, we should simply estimate $f$ as the mean of the observed data. BART will make few decisions in this scenario as proposals will provide little to no improvement to the likelihood. On the other hand, if we had some variable that completely explained our response, BART may consistently make decisions for each observed value of the feature.

Similiar to how variable importance is measured, we can assess the potential for interactions by calculating the proportion of successive decisions concerning two variables across posterior samples. Individual decisions/sequences of decisions do not have much meaning on there own, making these algorithms hard to explain. It makese sense though that if a variable is consistently used, it must be able to explain the response to some degree. These tools can be used to interpret a BART model, or to help with variable selection for another model. @fig-vimp_vint displays a matrix of variable importance and interaction measures for data simulated under as $Y=X_1(X_2 + X_3+X_6)+X_2\cdot X_6+\sin(X_1)+\cos(X_2)+\log(|X_3|)+X_4^2+\lfloor X_5\rfloor+\lceil X_6\rceil+\epsilon$. We see all interactions are found, but the plot suggests some evidence of an interaction between $X_3$ and $X_6$. The coefficient of variation is a measure used to compare one variable to another and does not have much meaning on it's own. Like any other measure in statistics, results must be scrutinized.

![Coefficient of variation matrix for variable importance and interaction](figures/vimp_pres.png){#fig-vimp_vint}

Before we move on to the data, we briefly discuss diagnostics for BART. Unlike the random forest algorithm, a BART model for a continuous response assumes normally distributed errors and constant variance. When using a BART model, we need to assess the normality assumption, model fit, and convergence. The bartMan R package \citep{bartMan} provides a convenient tool for diagnostics. @fig-bart_diag shows the diagnostics for the same model used for @fig-vimp_vint. The Q-Q plot and Histogram both indicate normality was reasonable as expected. We see constant variance is reasonable as well in the Fitted vs Residuals Plot. The actual vs fitted plot shows BART fits the data quite well as the observed and fitted values are quite close. Variable Importance intervals shows BART correctly identified all Variables as important as the intervals do not contain zero. The Trace Plot for Sigma shows the standard deviation has converged reasonably well, but we would most likely run the sampler longer in a real analysis. Additional convergence assesments should be performed. Bart models have many parameters, and it is not unheard of to avoid assessing the convergence of each tree. The thought behind this is we don't care about any of the individual trees, so as long as our predictions have converged the model fits reasonably well. Changing the number of trees, along with $\alpha$ and $\beta$ can help with convergence.

![Diagnostic plots for BART](figures/bart_diag.png){#fig-bart_diag}

```{python}
#| eval: false
#| echo: false
#| include: false


import ee
import geemap
import webbrowser
import matplotlib.pyplot as plt
import matplotlib as mpl


ee.Authenticate()
ee.Initialize(project='ee-bdevries252')

bb_long = 153.5557
bb_lat = -28.8371
bb_point = ee.Geometry.Point(bb_long, bb_lat)
lis_long = 153.1536
lis_lat = -28.4941
lis_point = ee.Geometry.Point(lis_long, lis_lat)
diff = [bb_long - lis_long, lis_lat - bb_lat]
mid_point = ee.Geometry.Point((bb_long + lis_long) / 2, (bb_lat + lis_lat) / 2)
mp_coords = mid_point.coordinates().getInfo()
bb_aoi = ee.Geometry.Rectangle([bb_long - 0.1, bb_lat - 0.1,
                                bb_long + 0.1, bb_lat + 0.1])

modis = ee.ImageCollection('MODIS/061/MCD12Q1')
modis = modis.filterBounds(bb_aoi)
aumd = modis.select("LC_Type2").sort('system:time_start', False).first()

task = ee.batch.Export.image.toDrive(
    image = aumd,
    description = 'MODIS_LandCover',
    fileNamePrefix ='modis_landcover2023',
    region = bb_aoi,  
    scale = 500,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()

built_im = ee.Image('JRC/GHSL/P2023A/GHS_BUILT_S/2020')
built_rast = built_im.select("built_surface")
task = ee.batch.Export.image.toDrive(
    image = built_rast,
    description = 'GHSL_built_surface2023',
    fileNamePrefix ='ghsl_built_surface2023',
    region = bb_aoi,  
    scale = 500,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()

era5 = ee.ImageCollection('ECMWF/ERA5_LAND/MONTHLY_BY_HOUR')
era5 = era5.filterBounds(bb_aoi).filterDate(ee.Date('2023'))
soil_im = era5.select("soil_temperature_level_1").first()
task = ee.batch.Export.image.toDrive(
    image = soil_im,
    description = 'era5_2023_soil_temp',
    fileNamePrefix ='era5_soil_temp',
    region = bb_aoi,  
    scale = 500,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()

precip_im = era5.select('total_precipitation').first()
task = ee.batch.Export.image.toDrive(
    image = precip_im,
    description = 'era5_2023_precip',
    fileNamePrefix ='era5_precip',
    region = bb_aoi,  
    scale = 500,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()


dems = ee.Image("AU/GA/DEM_1SEC/v10/DEM-H")
elevation = dems.select("elevation")
task = ee.batch.Export.image.toDrive(
    image = elevation,
    description = 'balina_byron_elev',
    fileNamePrefix = 'balina_byron_elev',
    region = bb_aoi,  
    scale = 30.92,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()

hansen_forest = ee.Image('UMD/hansen/global_forest_change_2023_v1_11').select('loss')
task = ee.batch.Export.image.toDrive(
    image = hansen_forest,
    description = 'forest_loss',
    fileNamePrefix = 'forest_loss',
    region = bb_aoi,  
    scale = 30.92,
    crs='EPSG:7844',
    maxPixels=1e13
)
task.start()
```

# Data {#sec:Data}

Before we can apply any of the models discussed to assess the importance of land cover on flying fox feeding locations, we need to extract and transform the data. The flying fox locations themselves form a point pattern, which can't be modelled directly by any of the algorithms discussed. We avoid modelling a point pattern by aggregating counts over a grid to create areal data. In this section we discuss the tools used to obtain and process our data.

```{python}
#| include: FALSE
#| echo: FALSE
#| eval: FALSE
import ee
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

ee.Authenticate()
ee.Initialize(project = 'ee-bdevries252')

dat = pd.read_csv('/home/benjamin/DeVries_WP/hull_final.csv')
bb_poly = ee.Geometry.Polygon([dat[['x', 'y']].values.tolist()])
bb_box = ee.Geometry.BBox(min(dat['x']), min(dat['y']), max(dat['x']), max(dat['y']))
bb_grid = bb_box.coveringGrid('EPSG:4326', np.sqrt(bb_poly.area().getInfo() / 4000))
bb_aoi = bb_grid.filterBounds(bb_poly)


coordinates = bb_poly.getInfo()['coordinates'][0]
x, y = zip(*coordinates)
plt.plot(x, y, color='blue')
grid_cells = bb_aoi.getInfo()['features']
for grid_cell in grid_cells:
    grid_coords = grid_cell['geometry']['coordinates'][0]
    grid_x, grid_y = zip(*grid_coords)
    plt.plot(grid_x + (grid_x[0],), grid_y + (grid_y[0],), color = 'red', linewidth = 0.5)
plt.grid(True)
plt.show()

def areaCells(cell):
    return cell.set('area_m2', ee.Geometry(cell.geometry()).area(ee.Number(1)))

bb_aoi = bb_aoi.map(areaCells)

task = ee.batch.Export.table.toDrive(
    collection = bb_aoi,
    description = 'writing_project_aoi',
    fileNamePrefix = 'bb_grid_5000',
    fileFormat = 'CSV'
)
task.start()

#csv
START = ee.Date('2023-08-01')
END = START.advance(1, 'year')
col_filter = ee.Filter.date(START, END)
band_names = ['water','trees','grass','flooded_vegetation','crops','shrub_and_scrub','built','bare']
dw_col = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').filter(col_filter)

for band in band_names:
    img = dw_col.select(band).median()
    zonal = img.reduceRegions(collection = bb_aoi, reducer = ee.Reducer.mean(), scale = 10)
    task = ee.batch.Export.table.toDrive(
        collection = zonal,
        description = f'DW_mean_{band}',
        fileNamePrefix = f'dynamic_world_mean_{band}',
        fileFormat = 'CSV'
    )
    task.start()
    print(f"Exporting: DW_mean_{band}")
# rasters

START = ee.Date('2023-08-01')
END = START.advance(1, 'year')

col_filter = ee.Filter.And(
    ee.Filter.bounds(ee.Geometry.Point(bb_long, bb_lat)),
    ee.Filter.date(START, END),
)
band_names = ['water', 'trees', 'grass', 'flooded_vegetation', 'crops', 'shrub_and_scrub', 'built', 'bare']
dw_col = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').filter(col_filter)
dw_ims = [ee.Image() for _ in range(8)]

for i in range(8):
  dw_ims[i] = dw_col.select(band_names[i]).median()
  
index = 0
for band in band_names:
    img = dw_ims[index]
    task = ee.batch.Export.image.toDrive(
        image=img.clip(bb_aoi),
        description=f'DW_{band}',
        fileNamePrefix=f'dynamic_world_{band}',
        region=bb_aoi.getInfo()['coordinates'],
        scale=10,
        maxPixels=1e13
    )
    task.start()
    print(f"Exporting: DW_{band}")
    index += 1

```

```{r}
#| include: FALSE
#| echo: FALSE
#| eval: FALSE

dw_files <- list.files(path = "~/Downloads/", pattern = "^dynamic_world.*\\.tif$",
                       full.names = T)
rast_dat <- as.data.frame(raster(dw_files[1]), xy = T)
vals <- apply(matrix(2 : length(dw_files)), 1, function (a) {
  rast <- raster(dw_files[a])
  dat <- as.data.frame(rast, xy = T)
  return(dat[, 3])
})
rast_dat <- cbind(rast_dat, vals)
rast_dat <- rast_dat |>
  rename("Bare" = bare,
                "Built" = `1`,
                "Crops" = `2`,
                "Flooded Veg." = `3`,
                "Grass" = `4`,
                "Shrub/Scrub" = `5`,
                "Trees" = `6`,
                "Water" = `7`) |> 
  pivot_longer(cols = -c(x, y), names_to = "layer", values_to = "value")
ggplot(data = rast_dat, aes(x = x, y = y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  facet_wrap(~ layer) +
  theme_void() +
  labs(x = "", y = "", fill = "Estimated Probability",
       title = "Dynamic World Land Cover Rasters 2022 Median Estimated Probability Near Ballina Byron") +
  guides(fill = guide_colorbar(direction = "horizontal", title.position = "top")) +
  theme(
    legend.position = c(0.7, 0),
    legend.justification = c(0, 0),
    legend.key.size = unit(0.9, "cm"),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
```

## Raster Data and Google Earth Engine

Rasters are used to store data with spatial components. Each pixel has an $(x,y)$ coordinate, and a variable of interest. We can visualize rasters by mapping the variable to a color. Gradient scales can be used for continuous values. For this project, we use rasters pulled via Google Earth Engine (GEE), \citep{gee}. GEE has a large database of satellite images and rasters of estimated attributes. Many earth engine datasets contain images describing different attributes of the land. These attributes are labelled bands.

An important component of spatial rasters is the coordinate reference system (CRS). We can think about the satellite images as pictures of a sphere. Using the position of the camera and other factors such as distance to the earth, $(x,y,z)$ coordinates can be assigned to each pixel. For spatial data, we need to know how far apart locations are on the sphere. Looking at a picture of a sphere, we can't determine how far apart points are due to the curvature. Gauss's Theorema Egregium (how to cite?) implies that no 2d map perfectly portrays the distance between points. We need to choose a CRS that preserves the distance between points for our area of interest reasonably well. The location on the earth and size of the area determine this choice. Each raster has a pre-specified CRS that may or may not be suitable, but we can always project the raster into another CRS.

Working with data from earth engine we can either select an individual image, or an image collection. An image corresponds to a specific band and time, while the image collection is the entire data set. When either is selected, we have access to every time and location available. With an image, we can clip area of interest, masking data outside this region. With an image collection, we can filter the dataset to a specific region and time period. After selecting a band, an individual image can be chosen. Alternatively, we can produce an image based calculation over the filtered time period and region. Images can then be exported to Google Drive and can be loaded into with the R raster package, \citep{raster}. After loading the raster, we can create a long formatted data structure for modelling.

## Land Cover and Dynamic World

One category of datasets on Google Earth Engine is land cover. Land cover describes natural and developed features of the earth as classes. A similiar but distinct class of datasets is land use, which describes how humans use the land. There are various methods to estimate land cover, and many models estimate different classes. Additionally, different datasets span various regions and time periods. The majority of land cover datasets are annual and not quite up to date. Estimates are produced in a multi-phase modelling process, considering many images along with external prior information. Working with recent data from Australia, there are fewer options, especially after excluding low resolution datasets. In this project, we utilize data from DynamicWorld V1 by \citep{dynamic_world}. Dynamic World is a daily high resolution land cover dataset derived from Sentinel-2 satelites. The estimated probability of each class in dynamic world is the output from a convolutional neural nets predictions on a single sattelite image.

Within Dynamic World there are ten bands, each containing a collection of images. In our analysis, we use eight relevant bands that each contain the estimated probability that a $100\ m^2$ region of the earth corresponds to the chosen band. Unsurprisingly, daily high resolution data is rife with missingness. To combat this, we compute the median land class over a selected period of time. Missing values are ignored in the calculation by default. This also helps slightly with the fact that Dynamic World estimates are based on an individual day. Weather and atmospheric factors may influence estimates so looking at the closest day may not be advisable. We don't expect major changes to land cover in a short period of time so this is reasonable. An individual image can then be produced based on some function of the images. A panel of the exported rasters is displayed in @dw_lc.

```{python}
#| eval: FALSE
#| echo: false

bb_long = 153.5557
bb_lat = -28.8371
bb_aoi = ee.Geometry.Rectangle([bb_long - 0.2, bb_lat - 0.2,
                                bb_long + 0.2, bb_lat + 0.2])
START = ee.Date('2022-01-01')
END = START.advance(1, 'year')

col_filter = ee.Filter.And(
    ee.Filter.bounds(ee.Geometry.Point(bb_long, bb_lat)),
    ee.Filter.date(START, END),
)
band_names = ['water', 'trees', 'grass', 'flooded_vegetation', 'crops', 'shrubs_and_scrub', 'built', 'bare']
dw_col = ee.ImageCollection('GOOGLE/DYNAMICWORLD/V1').filter(col_filter)
dw_ims = [ee.Image() for _ in range(8)]

for i in range(8):
  dw_ims[i] = dw_col.select(band_names[i]).median().clip(bb_aoi)
  
index = 0
for band in band_names:
    img = dw_ims[index]
    task = ee.batch.Export.image.toDrive(
        image = img,
        description = f'DW_{band}',
        fileNamePrefix = f'dynamic_world_{band}',
        region=bb_aoi.getInfo()['coordinates'],
        scale=10,
        maxPixels=1e13
    )
    task.start()
    print(f"Exporting: DW_{band}")
    index += 1
```

![Dynamic World Exports from Google Earth Engine](figures/2022_rast.png){#fig:dw_lc}

```{r}
#| eval: FALSE
#| echo: FALSE
#| include: FALSE

modis <- raster("~/Downloads/modis_landcover2023.tif")
modis_df <- as.data.frame(modis, xy = T) |> 
  mutate(land_cover = factor(LC_Type2, levels = c(0, 1, 2, 5, 8, 9, 10, 12, 13),
                             labels = c("Water Bodies",
                                        "Evergreen Needleleaf Forests",
                                        "Evergreen Broadleaf Forests",
                                        "Mixed Forests",
                                        "Woody Savannas",
                                        "Savannas",
                                        "Grasslands",
                                        "Croplands",
                                        "Urban and Built-up Lands")))
modis_pal <- c(
  "Water Bodies" = "#1c0dff",
  "Evergreen Needleleaf Forests" = "#05450a",
  "Evergreen Broadleaf Forests" = "#086a10",
  "Deciduous Broadleaf Forests" = "#78d203",
  "Mixed Forests" = "#009900",
  "Closed Shrublands" = "#c6b044",
  "Open Shrublands" = "#dcd159",
  "Woody Savannas" = "#dade48",
  "Savannas" = "#fbff13",
  "Grasslands" = "#b6ff05",
  "Croplands" = "#c24f44",
  "Urban and Built-up Lands" = "#a5a5a5",
  "Non-Vegetated Lands" = "#f9ffa4"
)
ggplot() +
  geom_raster(aes(x = x, y = y, fill = land_cover),
              data = modis_df) +
  scale_fill_manual(name = "Land Cover", values = modis_pal) +
  geom_point(aes(x = 153.5557, y = -28.8371, color = "Ballina Byron"), size = 5) +
  scale_color_manual(name = "Airport", values = c("magenta")) +
  labs(title = "MODIS Land Cover Raster for Eastern Australia 1/1/2023",
       x = "Longitude", y = "Latitude") +
  theme_minimal()
# 
# soil_temp <- raster("~/Downloads/era5_soil_temp.tif")
# soil_temp_df <- as.data.frame(soil_temp, xy = T)
# ggplot() +
#   geom_raster(data = soil_temp_df,
#               aes(x = x, y = y, fill = soil_temperature_level_1)) +
#   scale_fill_viridis_c()
# 
# precip_im <- raster("~/Downloads/era5_precip.tif")
# precip_df <- as.data.frame(precip_im, xy = T)
# ggplot() +
#   geom_raster(data = precip_df,
#               aes(x = x, y = y, fill = total_precipitation)) +
#   scale_fill_viridis_c()
# 
# elev_im <- raster("~/Downloads/balina_byron_elev.tif")
# elev_df <- as.data.frame(elev_im, xy = T)
# ggplot() +
#   geom_raster(aes(x = x, y = y, fill = elevation), data = elev_df) +
#   scale_fill_viridis_c()
# 
# forest_loss <- raster("~/Downloads/forest_loss.tif")
# forest_loss_df <- as.data.frame(forest_loss, xy = T)
# ggplot() +
#   geom_raster(aes(x = x, y = y, fill = elevation), data = elev_df, alpha = 0.8) +
#   scale_fill_viridis_c() +
#   geom_contour(aes(x = x, y = y, z = loss), data = forest_loss_df, color = "orange")
```

## Areal Data

https://gis.stackexchange.com/questions/323698/counting-points-in-polygons-with-sf-package-of-r

```{r}
#| echo: false
#| output: false

dat_228 <- read_csv("~/DeVries_WP/all_bat.csv")
extracted <- apply(matrix(dat_228[, 4]), 1, function(a) {
  return(str_extract_all(a, "-?\\d+\\.\\d+|-?\\d+")[[1]])
}) |> as.numeric() |>  as.data.frame()
colnames(extracted) <- "val_type"
extracted$row_id <- rep(1 : nrow(dat_228), each = 4)
extracted_wide <- cbind(extracted, rep(c("Long", "Lat", "Val1", "Val2"),
                                       nrow(dat_228))) |> 
  pivot_wider(
    id_cols = row_id,
    names_from = `rep(c(\"Long\", \"Lat\", \"Val1\", \"Val2\"), nrow(dat_228))`,
    values_from = val_type
  )
grid_ee <- read_csv("~/Downloads/dw_rasts/bb_grid_4000.csv")
grid_ee_sf <- geojson_sf(grid_ee$.geo)
bats_sf <- st_as_sf(extracted_wide[, 2 : 3], coords = c("Long", "Lat"))
st_crs(bats_sf) <- st_crs(grid_ee_sf)
grid_ee_sf$count <- lengths(st_intersects(grid_ee_sf, bats_sf))
```

```{r}

ggplot(grid_sf) +
  geom_sf(aes(fill = count), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(fill = "Bat Count")

ggplot() +
  geom_raster(aes(x = x, y = y, fill = water), data = rast_dat) +
  scale_fill_viridis_c() +
  ggnewscale::new_scale_fill() +
  geom_polygon(aes(x = x, y = y), fill = NA, colour = "black", data = hull_dat) +
  geom_point(aes(x = Long, y = Lat), color = "red", data = extracted_wide,
             alpha = 0.2)
```

# Modelling and Results

```{r}
dw_files <- list.files(path = "~/Downloads/dw_rasts/",
                       pattern = "^dynamic_world.*\\.csv$", full.names = T)
type <- c("bare", "built", "crops", "flooded", "grass", "shrub", "trees", "water")

for (i in 1 : length(dw_files)) {
  tmp <- read_csv(dw_files[i])
  colnames(tmp) <- c("index", paste0("area_", type[i]), paste0("prob_", type[i]),
                     "geo")
  grid_ee_sf <- cbind(grid_ee_sf, tmp[, 2 : 3])
}
grid_ee_sf$density <- grid_ee_sf$count / grid_ee_sf$area_bare
grid_ee_sf <- grid_ee_sf %>%
  mutate(centroid = st_centroid(geometry)) %>%
  mutate(
    lon = st_coordinates(centroid)[,1],
    lat = st_coordinates(centroid)[,2]
  )
coords <- st_coordinates(grid_ee_sf$centroid)
colnames(coords) <- c("lon", "lat")
relevant <- cbind(grid_ee_sf |> as.data.frame() |> select(count, starts_with("prob_"), area_bare), coords)
write_csv(relevant, "~/DeVries_WP/dw_4748.csv")
```

```{r}
dw_dat <- read_csv("~/DeVries_WP/dw_complete.csv")
# dw_dat <- st_as_sf(dw_dat)
# coords_fun <- function(a) {
#   vals <- a %>% 
#     gsub("list\\(c\\(|\\)", "", .) %>% 
#     strsplit(",") %>% 
#     .[[1]] %>% 
#     as.numeric()
#   lon <- vals[which(vals > 100)]
#   lat <- vals[which(vals <= 100)]
#   return(c(mean(lon), mean(lat)))
# }
# dw_dat <- dw_dat %>%
#   mutate(centroid = st_centroid(geometry)) %>%
#   mutate(
#     lon = st_coordinates(centroid)[,1],
#     lat = st_coordinates(centroid)[,2]
#   )
# coords <- sapply(dw_dat$geometry, coords_fun) |> t()
# colnames(coords) <- c("lon", "lat")
# rownames(coords) <- NULL
dat <- read_csv("~/DeVries_WP/dw_4748.csv")
X <- dat[, -c(1, 10)] |> as.matrix()
Y <- log(dat$count / dat$area_bare * 1e4 / 3 + .Machine$double.eps) |> as.vector()
m0 <- wbart(x.train = X, y.train = Y, ntree = 500, power = 2,
            ndpost = 10000, nskip = 10000)
bartDiag(m0, response = Y)
fit <- predict(m0, newdata = X)
counts <- apply(fit, c(1, 2), function(a) rpois(1, exp(a)))

crps <- crps_sample(dat$count, t(counts))
mosaic::fav_stats(crps)
```



# Conclusion
